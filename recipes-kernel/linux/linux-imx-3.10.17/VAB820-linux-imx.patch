diff --git a/arch/arm/boot/dts/imx6dl-vab820.dts b/arch/arm/boot/dts/imx6dl-vab820.dts
new file mode 100644
index 0000000..0172305
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-vab820.dts
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-vab820.dtsi"
+
+/ {
+	model = "VIA i.MX6 Dual-lite VAB-820 Board";
+	compatible = "via,imx6dl-vab820", "fsl,imx6dl";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-vab820.dts b/arch/arm/boot/dts/imx6q-vab820.dts
new file mode 100644
index 0000000..4828255
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-vab820.dts
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include "imx6qdl-vab820.dtsi"
+
+/ {
+	model = "VIA i.MX6 Quad VAB-820 Board";
+	compatible = "via,imx6q-vab820", "fsl,imx6q";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6qdl-vab820.dtsi b/arch/arm/boot/dts/imx6qdl-vab820.dtsi
new file mode 100644
index 0000000..529397c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-vab820.dtsi
@@ -0,0 +1,606 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	aliases {
+		mmc0 = &usdhc4;
+		mmc1 = &usdhc2;
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	hannstar_cabc {
+		compatible = "hannstar,cabc";
+
+		lvds0 {
+			gpios = <&gpio6 15 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
+
+		reg_usb_h1_vbus: usb_h1_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 0 1>; /* VAB-820 - low enable*/ 
+
+			/* SDB - high enable
+			gpio = <&gpio1 29 0>;
+			enable-active-high; */
+		};
+	}; 
+
+	/* VAB-820 - copied from imx6q-sabrelite.dts */
+	sound {
+		compatible = "fsl,imx6q-vab820-sgtl5000",
+			     "fsl,imx-audio-sgtl5000";
+		model = "imx6q-vab820-sgtl5000";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT";
+		mux-int-port = <2>;
+		mux-ext-port = <4>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB666";
+		mode_str ="LDB-XGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB565";
+		mode_str ="CLAA-WVGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB666";
+		mode_str ="LDB-SVGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB666";
+		mode_str ="LDB-VGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>; /*VAB-820*/  /*SDB - <&pwm1 0 5000000>;*/
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		power {
+			power-led-gpio = <&gpio4 5 0>;
+		};
+	};
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_4>; /*VAB-820*/  /*SDB - <&pinctrl_audmux_2>;*/
+	status = "okay";
+};
+
+/*VAB-820*/
+#if 0
+&cpu0 { 
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+#endif
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 19 0>; 	 /*VAB-820*/  /*SDB - <&gpio4 9 0>;*/
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1 &pinctrl_ecspi1_cs_1>; /*VAB-820 - copied from imx6qdl-sabreauto.dtsi*/  
+							      /*SDB-<&pinctrl_ecspi1_2>;*/
+	status = "okay";
+
+	flash1_0: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "sst,sst25vf032b"; /*VAB-820*/  /*SDB - "st,m25p32";*/
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+
+	flash1_1: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q32";
+		spi-max-frequency = <20000000>;
+		reg = <0>; /*Chip-Select number*/
+	};
+
+};
+
+/*VAB-820*/
+#if 1
+&ecspi3 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio4 24 0>, <&gpio4 25 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi3_1 &pinctrl_ecspi3_cs_1 &pinctrl_ecspi3_cs_2>;
+	status = "okay";
+
+	flash3_0: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "sst,sst25vf032b";
+		spi-max-frequency = <20000000>;
+		reg = <0>; /*Chip-Select number*/
+	};
+
+	flash3_1: m25p80@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "sst,sst25vf032b";
+		spi-max-frequency = <20000000>;
+		reg = <1>; /*Chip-Select number*/
+	};
+
+};
+#endif
+
+#if 0
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_3>;   /*VAB-820*/  /*SDB - <&pinctrl_enet_1>;*/
+	phy-mode = "rgmii";
+	phy-reset-gpios = <&gpio1 28 0>; /*VAB-820*/
+	status = "okay";
+};
+#endif
+/* VAB-820 : copied from Boundary's SabreLite  */
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_4>;
+	phy-mode = "rgmii";
+	status = "okay";
+
+	#address-cells = <0>;
+	#size-cells = <1>;
+
+	phy_int {
+		reg = <0x6>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <28 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_2>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_2>;
+	status = "okay";
+
+	/* VAB-820 - copied from imx6qdl-sabreauto.dtsi */
+	adv7180: adv7180@21 {
+		compatible = "adv,adv7180";
+		reg = <0x21>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_4>; /*VAB-820*/  /*AI - <&pinctrl_ipu1_3>;*/
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&reg_3p3v>; /* 3.3v, enabled via 2.8 VGEN6 */
+		AVDD-supply = <&reg_3p3v>;  /* 1.8v */
+		DVDD-supply = <&reg_3p3v>;  /* 1.8v */
+		PVDD-supply = <&reg_3p3v>;  /* 1.8v */
+		pwn-gpios = <&gpio1 16 GPIO_ACTIVE_LOW>; /*VAB-820*/  /*AI - <&max7310_b 2 0>;*/
+		rst-gpios = <&gpio1 17 GPIO_ACTIVE_LOW>; /*VAB-820*/
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		cvbs = <1>;
+	};
+
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_2>;
+	status = "okay";
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+        clock-frequency = <100000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_i2c3_2>;
+        status = "okay";
+
+        egalax_ts@04 {
+                compatible = "eeti,egalax_ts";
+                reg = <0x04>;
+                interrupt-parent = <&gpio6>;
+                interrupts = <8 2>;
+                wakeup-gpios = <&gpio6 8 0>;
+        };
+
+	/*VAB-820 - copied from imx6q-sabrelite.dts*/
+	codec: sgtl5000@0a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x0a>;
+		clocks = <&clks 201>;
+		VDDA-supply = <&reg_3p3v>;/*VAB-820*/ /*SBL - <&reg_2p5v>;*/
+		VDDIO-supply = <&reg_3p3v>;
+	};
+};
+
+
+&ldb {
+	ipu_id = <1>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <1>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+&pcie {
+	power-on-gpio = <&gpio1 19 0>; /*VAB-820*/  /*SDB - <&gpio3 19 0>;*/
+	reset-gpio = <&gpio7 12 GPIO_ACTIVE_LOW>;
+	wake-up-gpio = <&gpio5 20 GPIO_ACTIVE_LOW>;
+	disable-gpio = <&gpio4 9 0>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2_1>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_vab820>;
+	status = "okay";
+	fsl,uart-has-rtscts;
+	fsl,dte-mode;
+};
+
+
+&uart2 { 
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+	status = "okay";
+}; 
+
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	pinctrl-1 = <&pinctrl_usbh1_1>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;  /* VAB-820 */ /*pinctrl-0 = <&pinctrl_usdhc2_1>;*/
+	cd-gpios = <&gpio2 2 0>;
+	/*SDB - wp-gpios = <&gpio2 3 0>;*/
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usdhc4_1>;
+        bus-width = <8>;
+        non-removable;
+        no-1-8-v;
+	keep-power-in-suspend;
+        status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_vab820>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_1>;
+	status = "okay";
+};
+
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+
+	uart1 {
+		pinctrl_uart1_vab820: uart1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT6__UART1_TX_DATA 0x80000000
+				MX6QDL_PAD_SD3_DAT7__UART1_RX_DATA 0x80000000
+				MX6QDL_PAD_EIM_D20__UART1_CTS_B	0x80000000
+				MX6QDL_PAD_SD3_DAT0__UART1_RTS_B 0x130b0
+				MX6QDL_PAD_EIM_D24__UART1_DTR_B 0x130b0
+				MX6QDL_PAD_EIM_D25__UART1_DSR_B 0x80000000
+				MX6QDL_PAD_EIM_D23__UART1_DCD_B 0x80000000
+				//MX6QDL_PAD_EIM_EB3__UART1_RI_B 0x80000000
+			>;
+		};
+	};
+
+	flexcan1 {
+		pinctrl_flexcan1_vab820: flexcan1grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__FLEXCAN1_TX 0x80000000
+				MX6QDL_PAD_SD3_CLK__FLEXCAN1_RX 0x80000000
+			>;
+		};
+	};
+
+	hog {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01   0x80000000
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02   0x80000000
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04	0x80000000
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05	0x80000000
+				MX6QDL_PAD_GPIO_7__GPIO1_IO07	0x80000000
+				MX6QDL_PAD_GPIO_8__GPIO1_IO08	0x80000000
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09	0x80000000
+				MX6QDL_PAD_SD1_DAT0__GPIO1_IO16 0x80000000
+				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17 0x80000000
+				/*MX6QDL_PAD_SD1_DAT2__GPIO1_IO19 0x80000000	/*MX6Q_SABRELITE_PCIE_CSI_PWN*/
+				MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28 0x1b0b0 	/* ethernet phy interrupt - copied from boundary */
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02 0x80000000
+
+				MX6QDL_PAD_EIM_DA0__GPIO3_IO00  0x80000000
+				/*MX6QDL_PAD_EIM_D19__GPIO3_IO19  0x80000000*/ 	/*defined in &pinctrl_ecspi1_cs_1*/
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_EIM_D28__GPIO3_IO28  0x80000000
+				MX6QDL_PAD_GPIO_19__GPIO4_IO05  0x80000000
+				/*MX6QDL_PAD_KEY_ROW1__GPIO4_IO09 0x80000000	/*MX6Q_SABRELITE_PCIE_DIS_B*/
+				/*MX6QDL_PAD_DISP0_DAT3__GPIO4_IO24 0x80000000  /*MX6QDL_PAD_DISP0_DAT3__ECSPI3_SS0 ????*/
+				/*MX6QDL_PAD_DISP0_DAT4__GPIO4_IO25 0x80000000  /*MX6QDL_PAD_DISP0_DAT4__ECSPI3_SS1 ????*/
+
+				/*MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20 0x80000000/*MX6Q_SABRELITE_PCIE_WAKE_B*/
+				MX6QDL_PAD_NANDF_ALE__GPIO6_IO08 0x80000000
+
+				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15 0x80000000
+				MX6QDL_PAD_GPIO_16__GPIO7_IO11   0x80000000
+				/*MX6QDL_PAD_GPIO_17__GPIO7_IO12  0x80000000	/*MX6Q_SABRELITE_PCIE_RST_B*/
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13 0x80000000
+
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1 0x000b0 		/* SGTL5000 sys_mclk : copied from boundary */
+			>;
+		};
+	};
+
+	ecspi3 {
+		pinctrl_ecspi3_cs_1: ecspi3_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT3__GPIO4_IO24 0x80000000
+			>;
+		};
+
+		pinctrl_ecspi3_cs_2: ecspi3_cs_grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT4__GPIO4_IO25 0x80000000
+			>;
+		};
+	};
+
+	audmux {
+		/* VAB-820 */
+		pinctrl_audmux_4: audmux-4 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT20__AUD4_TXC  0x130b0
+				MX6QDL_PAD_DISP0_DAT21__AUD4_TXD  0x110b0
+				MX6QDL_PAD_DISP0_DAT22__AUD4_TXFS 0x130b0
+				MX6QDL_PAD_DISP0_DAT23__AUD4_RXD  0x130b0
+			>;
+		};
+	};
+
+	enet {
+		/* VAB-820 - remove ENET_TX_EN pin, set it as GPIO instead */
+		pinctrl_enet_4: enetgrp-4 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_4: ipu1grp-4 { /* VAB-820 - parallel camera, remove CSI0_DATA_EN */
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12    0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13    0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14    0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15    0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16    0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17    0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18    0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19    0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK   0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC      0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC     0x80000000
+			>;
+		};
+	};
+
+	pwm2 {
+		pinctrl_pwm2_1: pwm2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT9__PWM2_OUT 0x1b0b1
+			>;
+		};
+	};
+
+
+	usbh1 {
+		pinctrl_usbh1_1: usbh1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D30__USB_H1_OC      0x80000000
+			>;
+		};
+	};
+};
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index b1eebda..7ab1434 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -210,7 +210,12 @@ void machine_halt(void)
 	smp_send_stop();
 
 	local_irq_disable();
-	while (1);
+
+	// (Sylvia)
+	//while (1);
+	if (pm_power_off)
+		pm_power_off();
+
 }
 
 /*
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 5fb11af..493675f 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -56,19 +56,19 @@ static void mx6q_flexcan_switch(void)
 		 * after board power up. So we set the EN/STBY initial state to low
 		 * first then to high to guarantee the state transition successfully.
 		 */
-		gpio_set_value_cansleep(flexcan_en_gpio, 0);
-		gpio_set_value_cansleep(flexcan_stby_gpio, 0);
+		//gpio_set_value_cansleep(flexcan_en_gpio, 0);
+		//gpio_set_value_cansleep(flexcan_stby_gpio, 0);
 
-		gpio_set_value_cansleep(flexcan_en_gpio, 1);
-		gpio_set_value_cansleep(flexcan_stby_gpio, 1);
+		//gpio_set_value_cansleep(flexcan_en_gpio, 1);
+		//gpio_set_value_cansleep(flexcan_stby_gpio, 1);
 	} else {
 		/*
 		 * avoid to disable CAN xcvr if any of the CAN interfaces
 		 * are down. XCRV will be disabled only if both CAN2
 		 * interfaces are DOWN.
 		*/
-		gpio_set_value_cansleep(flexcan_en_gpio, 0);
-		gpio_set_value_cansleep(flexcan_stby_gpio, 0);
+		//gpio_set_value_cansleep(flexcan_en_gpio, 0);
+		//gpio_set_value_cansleep(flexcan_stby_gpio, 0);
 	}
 }
 
@@ -220,10 +220,12 @@ static void __init imx6q_csi_mux_init(void)
 	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (!IS_ERR(gpr)) {
 		if (of_machine_is_compatible("fsl,imx6q-sabresd") ||
-			of_machine_is_compatible("fsl,imx6q-sabreauto"))
+			of_machine_is_compatible("fsl,imx6q-sabreauto") ||
+			of_machine_is_compatible("via,imx6q-vab820")) // (Sylvia) add imx6q-vab820
 			regmap_update_bits(gpr, IOMUXC_GPR1, 1 << 19, 1 << 19);
 		else if (of_machine_is_compatible("fsl,imx6dl-sabresd") ||
-			 of_machine_is_compatible("fsl,imx6dl-sabreauto"))
+			 of_machine_is_compatible("fsl,imx6dl-sabreauto") ||
+			 of_machine_is_compatible("via,imx6dl-vab820")) // (Sylvia) add imx6dl-vab820
 			regmap_update_bits(gpr, IOMUXC_GPR13, 0x3F, 0x0C);
 	} else {
 		pr_err("%s(): failed to find fsl,imx6q-iomux-gpr regmap\n",
@@ -304,6 +306,35 @@ static const struct of_dev_auxdata imx6q_auxdata_lookup[] __initconst = {
 	{ /* sentinel */ }
 };
 
+/* (Sylvia) add turnoff led and hdmi when power off */
+static void turnoff_power_led(void)
+{
+	int power_led_gpio;
+	struct device_node *np;
+
+	np = of_find_node_by_path("/leds/power");
+	power_led_gpio = of_get_named_gpio(np, "power-led-gpio", 0);
+
+	gpio_request(power_led_gpio, "power-led");
+	gpio_direction_output(power_led_gpio, 0);
+}
+
+static void turnoff_hdmi(void)
+{
+	void __iomem *mx6_pwr_off = MX6Q_IO_ADDRESS(0x20c8130);
+	u32 value;
+	value = readl(mx6_pwr_off);
+	writel(value & 0xfffffffe , mx6_pwr_off);
+
+}
+
+static void mx6_poweroff(void)
+{
+	turnoff_power_led();
+	turnoff_hdmi();
+}
+
+
 static void __init imx6q_init_machine(void)
 {
 	struct device *parent;
@@ -320,6 +351,9 @@ static void __init imx6q_init_machine(void)
 	imx_anatop_init();
 	imx6_pm_init();
 	imx6q_csi_mux_init();
+
+	// (Sylvia)
+	pm_power_off = mx6_poweroff;
 }
 
 #define OCOTP_CFG3			0x440
diff --git a/drivers/media/platform/mxc/capture/adv7180.c b/drivers/media/platform/mxc/capture/adv7180.c
index ae17d7f..658b111 100644
--- a/drivers/media/platform/mxc/capture/adv7180.c
+++ b/drivers/media/platform/mxc/capture/adv7180.c
@@ -44,6 +44,7 @@ static struct regulator *avdd_regulator;
 static struct regulator *pvdd_regulator;
 static int pwn_gpio;
 
+static void adv7180_hard_reset(bool cvbs);
 static int adv7180_probe(struct i2c_client *adapter,
 			 const struct i2c_device_id *id);
 static int adv7180_detach(struct i2c_client *client);
@@ -482,6 +483,28 @@ static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
 	switch (a->type) {
 	/* These are all the possible cases. */
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+         // Added By Dylan
+          //Just take advantage of this standard ioctl func as s_input ioctl
+          //Select input from CVBS or S-Video
+          switch (a->parm.raw_data[0]) {
+                case 1:
+                        /* CVBS input on ANT3 */
+                        //insel = true;
+	                //adv7180_hard_reset(insel);
+                        adv7180_write_reg(ADV7180_INPUT_CTL, 0x04);
+                        pr_err ("ADV7180: Set input to CVBS\n");
+                        break;
+                case 2:
+                       /* S-Video input, Y on ANT1, C on ANT2 */
+                       //insel = false;
+	               //adv7180_hard_reset(insel);
+                       adv7180_write_reg(ADV7180_INPUT_CTL, 0x06);
+                       pr_err ("ADV7180: Set input to S-Video\n");
+                        break;
+                default:
+                        pr_err("ADV7180: Unkown input select, set nothing\n"); 
+                        break;
+          }
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
@@ -889,13 +912,21 @@ static void adv7180_hard_reset(bool cvbs)
 
 	if (cvbs) {
 		/* Set CVBS input on AIN1 */
-		adv7180_write_reg(ADV7180_INPUT_CTL, 0x00);
+		//adv7180_write_reg(ADV7180_INPUT_CTL, 0x00);
+
+		/* (Sylvia) added : Set CVBS input on AIN3 */
+		adv7180_write_reg(ADV7180_INPUT_CTL, 0x04);
+		adv7180_write_reg(0x27, 0x58);
 	} else {
 		/*
 		 * Set YPbPr input on AIN1,4,5 and normal
 		 * operations(autodection of all stds).
 		 */
-		adv7180_write_reg(ADV7180_INPUT_CTL, 0x09);
+		//adv7180_write_reg(ADV7180_INPUT_CTL, 0x09);
+
+		/* (Sylvia) added : Set Y/C input on AIN1,2 and normal */
+		adv7180_write_reg(ADV7180_INPUT_CTL, 0x06);
+		adv7180_write_reg(0x27, 0x69);
 	}
 
 	/* Datasheet recommends */
@@ -933,7 +964,7 @@ static void adv7180_hard_reset(bool cvbs)
 	adv7180_write_reg(0x24, 0x00);
 	adv7180_write_reg(0x25, 0x00);
 	adv7180_write_reg(0x26, 0x00);
-	adv7180_write_reg(0x27, 0x58);
+//	adv7180_write_reg(0x27, 0x58);
 	adv7180_write_reg(0x28, 0x00);
 	adv7180_write_reg(0x29, 0x00);
 	adv7180_write_reg(0x2A, 0x00);
diff --git a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
index 84b6e4e..6170154 100755
--- a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
+++ b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
@@ -72,7 +72,7 @@ static int video_nr = -1;
 
 /*! This data is used for the output to the display. */
 #define MXC_V4L2_CAPTURE_NUM_OUTPUTS	6
-#define MXC_V4L2_CAPTURE_NUM_INPUTS	2
+#define MXC_V4L2_CAPTURE_NUM_INPUTS	3
 static struct v4l2_output mxc_capture_outputs[MXC_V4L2_CAPTURE_NUM_OUTPUTS] = {
 	{
 	 .index = 0,
@@ -134,9 +134,18 @@ static struct v4l2_input mxc_capture_inputs[MXC_V4L2_CAPTURE_NUM_INPUTS] = {
 	 .std = V4L2_STD_UNKNOWN,
 	 .status = 0,
 	 },
-	{
+        {
 	 .index = 1,
-	 .name = "CSI MEM",
+	 .name = "CVBS",//changed by Dylan, default "CSI MEM"
+	 .type = V4L2_INPUT_TYPE_CAMERA,
+	 .audioset = 0,
+	 .tuner = 0,
+	 .std = V4L2_STD_UNKNOWN,
+	 .status = V4L2_IN_ST_NO_POWER,
+	 },
+	{ //Added by Dylan, add S-Video input
+	 .index = 2,
+	 .name = "S-VIDEO",
 	 .type = V4L2_INPUT_TYPE_CAMERA,
 	 .audioset = 0,
 	 .tuner = 0,
@@ -830,13 +839,13 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 		 * Force the capture window resolution to be crop bounds
 		 * for CSI MEM input mode.
 		 */
-		if (strcmp(mxc_capture_inputs[cam->current_input].name,
-			   "CSI MEM") == 0) {
+                if (strcmp(mxc_capture_inputs[cam->current_input].name,"CVBS") == 0  ||  
+                    strcmp(mxc_capture_inputs[cam->current_input].name,"S-VIDEO") == 0 ) {
 			f->fmt.pix.width = cam->crop_current.width;
 			f->fmt.pix.height = cam->crop_current.height;
 		}
-
-		if (cam->rotation >= IPU_ROTATE_90_RIGHT) {
+		
+                if (cam->rotation >= IPU_ROTATE_90_RIGHT) {
 			height = &f->fmt.pix.width;
 			width = &f->fmt.pix.height;
 		} else {
@@ -1613,7 +1622,12 @@ static int mxc_v4l_open(struct file *file)
 					 cam->low_power == false);
 
 		if (strcmp(mxc_capture_inputs[cam->current_input].name,
-			   "CSI MEM") == 0) {
+			   "CVBS") == 0) {
+#if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
+			err = csi_enc_select(cam);
+#endif
+                } else if (strcmp(mxc_capture_inputs[cam->current_input].name,
+			   "S-VIDEO") == 0) {
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
 			err = csi_enc_select(cam);
 #endif
@@ -1770,7 +1784,12 @@ static int mxc_v4l_close(struct file *file)
 		pr_debug("mxc_v4l_close: release resource\n");
 
 		if (strcmp(mxc_capture_inputs[cam->current_input].name,
-			   "CSI MEM") == 0) {
+			   "CVBS") == 0) {
+#if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
+			err |= csi_enc_deselect(cam);
+#endif
+                } else if (strcmp(mxc_capture_inputs[cam->current_input].name,
+			   "S-VIDEO") == 0) {
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
 			err |= csi_enc_deselect(cam);
 #endif
@@ -1901,7 +1920,8 @@ static long mxc_v4l_do_ioctl(struct file *file,
 			    unsigned int ioctlnr, void *arg)
 {
 	struct video_device *dev = video_devdata(file);
-	cam_data *cam = video_get_drvdata(dev);
+	struct v4l2_streamparm inparm;
+        cam_data *cam = video_get_drvdata(dev);
 	int retval = 0;
 	unsigned long lock_flags;
 
@@ -2336,9 +2356,23 @@ static long mxc_v4l_do_ioctl(struct file *file,
 							V4L2_IN_ST_NO_POWER;
 		}
 
-		if (strcmp(mxc_capture_inputs[*index].name, "CSI MEM") == 0) {
+	if (strcmp(mxc_capture_inputs[*index].name, "CVBS") == 0) {
+#if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
+		        pr_err ("MXC V4L2 Capture: Choose capture input CVBS\n");
+                        inparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+                        inparm.parm.raw_data[0] = 1; //input select flag of adv7180
+	                vidioc_int_s_parm(cam->sensor, &inparm);	
+                        retval = csi_enc_select(cam);
+			if (retval)
+				break;
+#endif
+                } else if (strcmp(mxc_capture_inputs[*index].name,"S-VIDEO") == 0){
 #if defined(CONFIG_MXC_IPU_CSI_ENC) || defined(CONFIG_MXC_IPU_CSI_ENC_MODULE)
-			retval = csi_enc_select(cam);
+			pr_err ("MXC V4L2 Capture: Choose capture input S-Video\n");
+                        inparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+                        inparm.parm.raw_data[0] = 2; //input select flag of adv7180
+	                vidioc_int_s_parm(cam->sensor, &inparm);
+                        retval = csi_enc_select(cam);
 			if (retval)
 				break;
 #endif
diff --git a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h
index 09a421f..710f2e9 100644
--- a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h
+++ b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.h
@@ -40,7 +40,7 @@
 #include <media/v4l2-int-device.h>
 
 
-#define FRAME_NUM 10
+#define FRAME_NUM 30
 #define MXC_SENSOR_NUM 2
 
 enum imx_v4l2_devtype {
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index dd27b07..9ae9b54 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -96,6 +96,7 @@ struct mmc_blk_data {
 #define MMC_BLK_CMD23	(1 << 0)	/* Can do SET_BLOCK_COUNT for multiblock */
 #define MMC_BLK_REL_WR	(1 << 1)	/* MMC Reliable write support */
 #define MMC_BLK_PACKED_CMD	(1 << 2)	/* MMC packed command support */
+#define MMC_BLK_SUSPENDED	(1 << 3)	/* MMC block device suspended */
 
 	unsigned int	usage;
 	unsigned int	read_only;
@@ -106,6 +107,8 @@ struct mmc_blk_data {
 #define MMC_BLK_WRITE		BIT(1)
 #define MMC_BLK_DISCARD		BIT(2)
 #define MMC_BLK_SECDISCARD	BIT(3)
+#define MMC_BLK_RPMB		BIT(4)
+#define MMC_BLK_USER		BIT(5)
 
 	/*
 	 * Only set in main mmc_blk_data associated
@@ -146,6 +149,10 @@ static inline void mmc_blk_clear_packed(struct mmc_queue_req *mqrq)
 	packed->blocks = 0;
 }
 
+static int mmc_rpmb_req_process(struct mmc_blk_data *,
+		struct mmc_ioc_rpmb_req *);
+
+
 static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 {
 	struct mmc_blk_data *md;
@@ -891,6 +898,118 @@ static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)
 	md->reset_done &= ~type;
 }
 
+static int mmc_rpmb_req_process(struct mmc_blk_data *md,
+		struct mmc_ioc_rpmb_req *req)
+{
+	struct mmc_core_rpmb_req rpmb_req;
+	struct mmc_card *card = NULL;
+	int ret;
+
+	if (!md || !req)
+		return -EINVAL;
+
+	if (!(md->flags & MMC_BLK_CMD23) ||
+			(md->part_type != EXT_CSD_PART_CONFIG_ACC_RPMB))
+		return -EOPNOTSUPP;
+
+	card = md->queue.card;
+	if (!card || !mmc_card_mmc(card) || !card->ext_csd.rpmb_size)
+		return -ENODEV;
+
+	memset(&rpmb_req, 0, sizeof(struct mmc_core_rpmb_req));
+	rpmb_req.req = req;
+	/* check request */
+	ret = mmc_rpmb_pre_frame(&rpmb_req, card);
+	if (ret) {
+		pr_err("%s: prepare frame failed\n", mmc_hostname(card->host));
+		return ret;
+	}
+
+	mmc_claim_host(card->host);
+
+	if (md->flags & MMC_BLK_SUSPENDED) {
+		pr_warn("%s: MMC block device is already suspended\n",
+			mmc_hostname(card->host));
+		ret = -EPERM;
+		goto out;
+	}
+
+	/* wait for background operation finished */
+	mmc_stop_bkops(card);
+
+	/*
+	 * before start, let's change to RPMB partition first
+	 */
+	ret = mmc_blk_part_switch(card, md);
+	if (ret) {
+		pr_err("%s: Invalid RPMB partition switch (%d)!\n",
+				mmc_hostname(card->host), ret);
+		/*
+		 * In case partition is not in user data area, make
+		 * a force partition switch.
+		 * we need reset eMMC card at here
+		 */
+		ret = mmc_blk_reset(md, card->host, MMC_BLK_RPMB);
+		if (!ret)
+			mmc_blk_reset_success(md, MMC_BLK_RPMB);
+		else
+			pr_err("%s: eMMC card reset failed (%d)\n",
+					mmc_hostname(card->host), ret);
+		goto out;
+	}
+
+	ret = mmc_rpmb_partition_ops(&rpmb_req, card);
+	if (ret)
+		pr_err("%s: failed (%d) to handle RPMB request type (%d)!\n",
+				mmc_hostname(card->host), ret, req->type);
+out:
+	mmc_release_host(card->host);
+	mmc_rpmb_post_frame(&rpmb_req);
+	return ret;
+}
+
+int mmc_access_rpmb(struct mmc_queue *mq)
+{
+	struct mmc_blk_data *md = mq->data;
+	/*
+	 * If this is a RPMB partition access, return ture
+ */
+	if (md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(mmc_access_rpmb);
+
+int mmc_rpmb_req_handle(struct device *emmc, struct mmc_ioc_rpmb_req *req)
+{
+	int ret = 0;
+	struct gendisk *disk    = NULL;
+	struct mmc_blk_data *md = NULL;
+
+	if (!emmc || !req)
+		return -EINVAL;
+
+	disk = dev_to_disk(emmc);
+	if (!disk) {
+		pr_err("%s: NO eMMC disk found. Try it later\n",
+				__func__);
+		return -ENODEV;
+	}
+
+	md = mmc_blk_get(disk);
+	if (!md) {
+		pr_err("%s: NO eMMC block data. Try it later\n",
+				__func__);
+		return -ENODEV;
+	}
+	ret = mmc_rpmb_req_process(md, req);
+	mmc_blk_put(md);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(mmc_rpmb_req_handle);
+
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -1899,11 +2018,17 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 
 	ret = mmc_blk_part_switch(card, md);
 	if (ret) {
-		if (req) {
-			blk_end_request_all(req, -EIO);
-		}
-		ret = 0;
-		goto out;
+
+		pr_err("%s: switch part failed. Try to reset eMMC\n",
+				mmc_hostname(card->host));
+		if (mmc_blk_reset(md, card->host, MMC_BLK_USER)) {
+			if (req)
+				blk_end_request_all(req, -EIO);
+			ret = 0;
+			goto out;
+ 		}
+		pr_info("%s: Reset eMMC success\n", mmc_hostname(card->host));
+		mmc_blk_reset_success(md, MMC_BLK_USER);
 	}
 
 	mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
@@ -1977,7 +2102,15 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	 * index anymore so we keep track of a name index.
 	 */
 	if (!subname) {
-		md->name_idx = find_first_zero_bit(name_use, max_devices);
+		int idx;
+
+		idx = mmc_get_reserved_index(card->host);
+		if (idx >= 0 && !test_bit(idx, name_use))
+			md->name_idx = idx;
+		else
+			md->name_idx = find_next_zero_bit(name_use, max_devices,
+					mmc_first_nonreserved_index());
+
 		__set_bit(md->name_idx, name_use);
 	} else
 		md->name_idx = ((struct mmc_blk_data *)
@@ -2366,6 +2499,19 @@ static int mmc_blk_suspend(struct mmc_card *card)
 		mmc_queue_suspend(&md->queue);
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_suspend(&part_md->queue);
+			if (part_md->part_type ==
+				EXT_CSD_PART_CONFIG_ACC_RPMB) {
+				/*
+				 * RPMB partition is accessed by API directly.
+				 * Driver need to set a flag when suspending
+				 * MMC block device to notify API that the
+				 * accessing of RPMB partition needs to be
+				 * stopped
+				 */
+				mmc_claim_host(card->host);
+				part_md->flags |= MMC_BLK_SUSPENDED;
+				mmc_release_host(card->host);
+			}
 		}
 	}
 	return 0;
@@ -2385,6 +2531,18 @@ static int mmc_blk_resume(struct mmc_card *card)
 		mmc_queue_resume(&md->queue);
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_resume(&part_md->queue);
+			if (part_md->part_type ==
+					EXT_CSD_PART_CONFIG_ACC_RPMB) {
+				/*
+				 * RPMB partition is accessed by API directly.
+				 * Driver need to clear MMC_BLK_SUSPENDED flag
+				 * to make sure the next RPMB partition access
+				 * request won't be blocked
+				 */
+				mmc_claim_host(card->host);
+				part_md->flags &= ~MMC_BLK_SUSPENDED;
+				mmc_release_host(card->host);
+			}
 		}
 	}
 	return 0;
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 9447a0e..8d56557 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -37,7 +37,8 @@ static int mmc_prep_request(struct request_queue *q, struct request *req)
 		return BLKPREP_KILL;
 	}
 
-	if (mq && mmc_card_removed(mq->card))
+	//if (mq && mmc_card_removed(mq->card))
+	if (mq && (mmc_card_removed(mq->card) || mmc_access_rpmb(mq)))
 		return BLKPREP_KILL;
 
 	req->cmd_flags |= REQ_DONTPREP;
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 5752d50..00cd1c2 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -70,7 +70,9 @@ extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
 extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
+
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
+extern int mmc_access_rpmb(struct mmc_queue *);
 #endif
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c40396f..5a46488 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -16,6 +16,7 @@
 #include <linux/completion.h>
 #include <linux/device.h>
 #include <linux/delay.h>
+#include <linux/of.h>
 #include <linux/pagemap.h>
 #include <linux/err.h>
 #include <linux/leds.h>
@@ -2789,6 +2790,41 @@ void mmc_init_context_info(struct mmc_host *host)
 	init_waitqueue_head(&host->context_info.wait);
 }
 
+static int __mmc_max_reserved_idx = -1;
+
+/**
+ * mmc_first_nonreserved_index() - get the first index that is not reserved
+ */
+int mmc_first_nonreserved_index(void)
+{
+	return __mmc_max_reserved_idx + 1;
+}
+
+/**
+ * mmc_get_reserved_index() - get the index reserved for this host
+ *
+ * Return: The index reserved for this host or negative error value if
+ *         no index is reserved for this host
+ */
+int mmc_get_reserved_index(struct mmc_host *host)
+{
+	return of_alias_get_id(host->parent->of_node, "mmc");
+}
+
+static void mmc_of_reserve_idx(void)
+{
+	int max;
+
+	max = of_alias_max_index("mmc");
+	if (max < 0)
+		return;
+
+	__mmc_max_reserved_idx = max;
+
+	pr_debug("MMC: reserving %d slots for of aliases\n",
+			__mmc_max_reserved_idx + 1);
+}
+
 static int __init mmc_init(void)
 {
 	int ret;
@@ -2797,6 +2833,8 @@ static int __init mmc_init(void)
 	if (!workqueue)
 		return -ENOMEM;
 
+	mmc_of_reserve_idx();
+
 	ret = mmc_register_bus();
 	if (ret)
 		goto destroy_workqueue;
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 2a3593d..b0867c4 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -417,6 +417,8 @@ void mmc_of_parse(struct mmc_host *host)
 
 EXPORT_SYMBOL(mmc_of_parse);
 
+int mmc_max_reserved_idx(void);
+
 /**
  *	mmc_alloc_host - initialise the per-host structure.
  *	@extra: sizeof private data structure
@@ -428,6 +430,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int err;
 	struct mmc_host *host;
+	int alias_id, min_idx, max_idx;
 
 	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
 	if (!host)
@@ -437,7 +440,18 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	host->rescan_disable = 1;
 	idr_preload(GFP_KERNEL);
 	spin_lock(&mmc_host_lock);
-	err = idr_alloc(&mmc_host_idr, host, 0, 0, GFP_NOWAIT);
+
+	host->parent = dev;
+	alias_id = mmc_get_reserved_index(host);
+	if (alias_id >= 0) {
+		min_idx = alias_id;
+		max_idx = alias_id + 1;
+	} else {
+		min_idx = mmc_first_nonreserved_index();
+		max_idx = 0;
+	}
+
+	err = idr_alloc(&mmc_host_idr, host, min_idx, max_idx, GFP_NOWAIT);
 	if (err >= 0)
 		host->index = err;
 	spin_unlock(&mmc_host_lock);
@@ -447,7 +461,6 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 
 	dev_set_name(&host->class_dev, "mmc%d", host->index);
 
-	host->parent = dev;
 	host->class_dev.parent = dev;
 	host->class_dev.class = &mmc_host_class;
 	device_initialize(&host->class_dev);
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 61fb652..94db13e 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -293,7 +293,7 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 6) {
+	if (card->ext_csd.rev > 7) {
 		pr_err("%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
@@ -502,6 +502,11 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		 * RPMB regions are defined in multiples of 128K.
 		 */
 		card->ext_csd.raw_rpmb_size_mult = ext_csd[EXT_CSD_RPMB_MULT];
+
+		card->ext_csd.rpmb_size = 128 *
+			card->ext_csd.raw_rpmb_size_mult;
+		card->ext_csd.rpmb_size <<= 2; /* Unit: half sector */
+
 		if (ext_csd[EXT_CSD_RPMB_MULT] && mmc_host_cmd23(card->host)) {
 			mmc_part_add(card, ext_csd[EXT_CSD_RPMB_MULT] << 17,
 				EXT_CSD_PART_CONFIG_ACC_RPMB,
@@ -552,6 +557,17 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 	} else {
 		card->ext_csd.data_sector_size = 512;
 	}
+	/*
+	 * If use legacy relaible write, then the blk counts must not
+	 * big than the relaible write sectors
+	 */
+	if (!(card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN)) {
+		if (card->ext_csd.rel_sectors < RPMB_AVALIABLE_SECTORS)
+			card->rpmb_max_req = card->ext_csd.rel_sectors;
+		else
+			card->rpmb_max_req = RPMB_AVALIABLE_SECTORS;
+	} else
+		card->rpmb_max_req = RPMB_AVALIABLE_SECTORS;
 
 out:
 	return err;
@@ -1006,6 +1022,7 @@ MMC_DEV_ATTR(enhanced_area_offset, "%llu\n",
 MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
 MMC_DEV_ATTR(raw_rpmb_size_mult, "%#x\n", card->ext_csd.raw_rpmb_size_mult);
 MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
+MMC_DEV_ATTR(rpmb_size, "%d\n", card->ext_csd.rpmb_size);
 DEVICE_ATTR(boot_info, S_IRUGO, mmc_boot_info_show, NULL);
 DEVICE_ATTR(boot_config, S_IWUGO, NULL, setup_boot_partitions);
 DEVICE_ATTR(boot_bus_config, S_IWUGO, NULL, setup_boot_bus);
@@ -1027,6 +1044,7 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_enhanced_area_size.attr,
 	&dev_attr_raw_rpmb_size_mult.attr,
 	&dev_attr_rel_sectors.attr,
+	&dev_attr_rpmb_size.attr,
 	&dev_attr_boot_info.attr,
 	&dev_attr_boot_config.attr,
 	&dev_attr_boot_bus_config.attr,
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 83d17a9..479d491 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -644,3 +644,401 @@ int mmc_send_hpi_cmd(struct mmc_card *card, u32 *status)
 
 	return 0;
 }
+
+
+
+static int mmc_rpmb_send_command(struct mmc_card *card, u8 *buf, __u16 blks,
+		__u16 type, u8 req_type)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_command sbc = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+	u8 *transfer_buf = NULL;
+
+	mrq.sbc = &sbc;
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	mrq.stop = NULL;
+	transfer_buf = kzalloc(512 * blks, GFP_KERNEL);
+	if (!transfer_buf)
+		return -ENOMEM;
+
+	/*
+	 * set CMD23
+	 */
+	sbc.opcode = MMC_SET_BLOCK_COUNT;
+	sbc.arg = blks;
+	if ((req_type == RPMB_REQ) && type == RPMB_WRITE_DATA)
+		sbc.arg |= 1 << 31;
+	sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	/*
+	 * set CMD25/18
+	 */
+	sg_init_one(&sg, transfer_buf, 512 * blks);
+	if (req_type == RPMB_REQ) {
+		cmd.opcode = MMC_WRITE_MULTIPLE_BLOCK;
+		sg_copy_from_buffer(&sg, 1, buf, 512 * blks);
+		data.flags |= MMC_DATA_WRITE;
+	} else {
+		cmd.opcode = MMC_READ_MULTIPLE_BLOCK;
+		data.flags |= MMC_DATA_READ;
+	}
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+	data.blksz = 512;
+	data.blocks = blks;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	mmc_set_data_timeout(&data, card);
+
+	mmc_wait_for_req(card->host, &mrq);
+
+	if (req_type != RPMB_REQ)
+		sg_copy_to_buffer(&sg, 1, buf, 512 * blks);
+
+	kfree(transfer_buf);
+
+	if (cmd.error)
+		return cmd.error;
+	if (data.error)
+		return data.error;
+	return 0;
+}
+
+void mmc_rpmb_post_frame(struct mmc_core_rpmb_req *rpmb_req)
+{
+	int i;
+	struct mmc_ioc_rpmb_req *p_req;
+	__u8 *buf_frame;
+
+	if (!rpmb_req || !rpmb_req->ready)
+		return;
+
+	p_req = rpmb_req->req;
+	buf_frame = rpmb_req->frame;
+
+	if (!p_req || !buf_frame)
+		return;
+	/*
+	 * Regarding to the check rules, here is the post
+	 * rules
+	 * All will return result.
+	 * GET_WRITE_COUNTER:
+	 *              must: write counter, nonce
+	 *              optional: MAC
+	 * WRITE_DATA:
+	 *              must: MAC, write counter
+	 * READ_DATA:
+	 *              must: nonce, data
+	 *              optional: MAC
+	 * PROGRAM_KEY:
+	 *              must: Nothing
+	 *
+	 * Except READ_DATA, all of these operations only need to parse
+	 * one frame. READ_DATA needs blks frames to get DATA
+	 */
+
+	memcpy(p_req->result, buf_frame + RPMB_RES_BEG, 2);
+	*p_req->result = be16_to_cpup(p_req->result);
+
+	if (p_req->type == RPMB_PROGRAM_KEY)
+		goto out;
+
+	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
+			p_req->type == RPMB_WRITE_DATA) {
+		memcpy(p_req->wc, buf_frame + RPMB_WCOUNTER_BEG, 4);
+		*p_req->wc = be32_to_cpup(p_req->wc);
+	}
+
+	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
+			p_req->type == RPMB_READ_DATA) {
+		/* nonce copy */
+		memcpy(p_req->nonce, buf_frame + RPMB_NONCE_BEG, 16);
+	}
+	/*
+	 * Take MAC within the last package
+	 */
+	if (p_req->type == RPMB_READ_DATA) {
+		__u8 *data = p_req->data;
+		for (i = 0; i < p_req->blk_cnt; i++) {
+			memcpy(data, buf_frame + i * 512 + RPMB_DATA_BEG, 256);
+			data += 256;
+		}
+		/*
+		 * MAC stored in the last package
+		 */
+		if (p_req->mac) {
+			i--;
+			memcpy(p_req->mac, buf_frame + i * 512 + RPMB_MAC_BEG,
+					32);
+		}
+	} else if (p_req->mac)
+		memcpy(p_req->mac, buf_frame + RPMB_MAC_BEG, 32);
+out:
+	kfree(buf_frame);
+	rpmb_req->frame = NULL;
+	return;
+}
+EXPORT_SYMBOL_GPL(mmc_rpmb_post_frame);
+
+static int mmc_rpmb_request_check(struct mmc_card *card,
+		struct mmc_ioc_rpmb_req *p_req)
+{
+	/*
+	 * Some paramter is a must for the operation. Different
+	 * operation expect different paramters. Below code is
+	 * used for checking this.
+	 *
+	 * All operations will need result.
+	 * GET_WRITE_COUNTER:
+	 *              must: write counter, nonce
+	 *              optional: MAC
+	 * WRITE_DATA:
+	 *              must: MAC, data, write counter
+	 * READ_DATA:
+	 *              must: nonce, data
+	 *              optional: MAC
+	 * PROGRAM_KEY:
+	 *              must: MAC
+	 *
+	 * So here, we only check the 'must' paramters
+	 */
+	if (!p_req->result) {
+		pr_err("%s: Type %d has NULL pointer for result\n",
+				mmc_hostname(card->host), p_req->type);
+		return -EINVAL;
+	}
+
+	if (p_req->type == RPMB_GET_WRITE_COUNTER) {
+		if (!p_req->nonce || !p_req->wc) {
+			pr_err("%s: Type %d has NULL pointer for nonce/wc\n",
+					mmc_hostname(card->host), p_req->type);
+			return -EINVAL;
+		}
+		/*
+		 * used to allocate frame
+		 */
+		p_req->blk_cnt = 1;
+	} else if (p_req->type == RPMB_WRITE_DATA ||
+			p_req->type == RPMB_READ_DATA) {
+		if ((__u32)(p_req->addr + p_req->blk_cnt) >
+				card->ext_csd.rpmb_size) {
+			pr_err("%s Type %d: beyond the RPMB partition rang addr %d, blk_cnt %d, rpmb_size %d\n",
+					mmc_hostname(card->host),
+					p_req->type,
+					p_req->addr,
+					p_req->blk_cnt,
+					card->ext_csd.rpmb_size);
+			/*
+			 * Not return error here since we want device to handle
+			 * such errors
+			 */
+		}
+		if (p_req->blk_cnt == 0) {
+			pr_err("%s: Type %d has zero block count\n",
+					mmc_hostname(card->host),
+					p_req->blk_cnt);
+			return -EINVAL;
+		} else if (p_req->blk_cnt > card->rpmb_max_req) {
+			pr_err("%s: Type %d has invalid block count, cannot large than %d\n",
+					mmc_hostname(card->host),
+					p_req->blk_cnt,
+					card->rpmb_max_req);
+			return -EINVAL;
+		}
+		if (!p_req->data) {
+			pr_err("%s: Type %d has NULL pointer for data\n",
+					mmc_hostname(card->host), p_req->type);
+			return -EINVAL;
+		}
+		if (p_req->type == RPMB_WRITE_DATA) {
+			if (!p_req->wc || !p_req->mac) {
+				pr_err("%s: Type %d has NULL pointer for write counter/MAC\n",
+						mmc_hostname(card->host),
+						p_req->type);
+				return -EINVAL;
+		}
+		} else {
+			if (!p_req->nonce) {
+				pr_err("%s: Type %d has NULL pointer for nonce\n",
+						mmc_hostname(card->host),
+						p_req->type);
+				return -EINVAL;
+			}
+		}
+	} else
+		return -EOPNOTSUPP;
+
+	return 0;
+}
+
+/*
+ * prepare the request of RPMB frame
+ * RPMB frame is MSB first
+ * convert needed bytes
+ * return how many frames will be prepared
+ */
+int mmc_rpmb_pre_frame(struct mmc_core_rpmb_req *rpmb_req,
+		struct mmc_card *card)
+{
+	int i, ret;
+	struct mmc_ioc_rpmb_req *p_req;
+	__u8 *buf_frame;
+	__u16 blk_cnt, addr, type;
+	__u32 w_counter;
+
+	if (!rpmb_req || !card)
+		return -EINVAL;
+
+	p_req = rpmb_req->req;
+	if (!p_req) {
+		pr_err("%s: mmc_ioc_rpmb_req is NULL. Wrong parameter\n",
+				mmc_hostname(card->host));
+		return -EINVAL;
+	}
+
+	/*
+	 * make sure these two items are clear
+	 */
+	rpmb_req->ready = 0;
+	rpmb_req->frame = NULL;
+
+	ret = mmc_rpmb_request_check(card, p_req);
+	if (ret)
+		return ret;
+
+	buf_frame = kzalloc(512 * p_req->blk_cnt, GFP_KERNEL);
+	if (!buf_frame) {
+		pr_err("%s: cannot allocate frame for type %d\n",
+				mmc_hostname(card->host), p_req->type);
+		return -ENOMEM;
+	}
+
+	type = cpu_to_be16p(&p_req->type);
+	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
+			p_req->type == RPMB_READ_DATA) {
+		/*
+		 * One package prepared
+		 * This request needs Nonce and type
+		 * If is data read, then also need addr
+		 */
+		memcpy(buf_frame + RPMB_TYPE_BEG, &type, 2);
+		if (p_req->type == RPMB_READ_DATA) {
+			addr = cpu_to_be16p(&p_req->addr);
+			memcpy(buf_frame + RPMB_ADDR_BEG, &addr, 2);
+		}
+		/* convert Nonce code */
+		memcpy(buf_frame + RPMB_NONCE_BEG, p_req->nonce, 16);
+	} else if (p_req->type == RPMB_WRITE_DATA) {
+		__u8 *data = p_req->data;
+		/*
+		 * multiple package prepared
+		 * This request nees blk_cnt, addr, write_counter,
+		 * data and mac
+		 */
+		blk_cnt = cpu_to_be16p(&p_req->blk_cnt);
+		addr = cpu_to_be16p(&p_req->addr);
+		w_counter = cpu_to_be32p(p_req->wc);
+		for (i = 0; i < p_req->blk_cnt; i++) {
+			memcpy(buf_frame + i * 512 + RPMB_TYPE_BEG,
+					&type, 2);
+			memcpy(buf_frame + i * 512 + RPMB_BLKS_BEG,
+					&blk_cnt, 2);
+			memcpy(buf_frame + i * 512 + RPMB_ADDR_BEG,
+					&addr, 2);
+			memcpy(buf_frame + i * 512 + RPMB_WCOUNTER_BEG,
+					&w_counter, 4);
+			memcpy(buf_frame + i * 512 + RPMB_DATA_BEG,
+					data, 256);
+			data += 256;
+		}
+		/* convert MAC code */
+		memcpy(buf_frame + 512 * (i - 1) + RPMB_MAC_BEG,
+				p_req->mac, 32);
+	} else {
+		pr_err("%s: We shouldn't be here\n", mmc_hostname(card->host));
+		kfree(buf_frame);
+		return -EINVAL;
+	}
+	rpmb_req->ready = 1;
+	rpmb_req->frame = buf_frame;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mmc_rpmb_pre_frame);
+
+int mmc_rpmb_partition_ops(struct mmc_core_rpmb_req *rpmb_req,
+		struct mmc_card *card)
+{
+	int err = 0;
+	struct mmc_ioc_rpmb_req *p_req;
+	__u16 type, blks;
+	__u8 *buf_frame;
+
+	if (!rpmb_req || !card)
+		return -EINVAL;
+
+	p_req = rpmb_req->req;
+	buf_frame = rpmb_req->frame;
+
+	if (!p_req || !rpmb_req->ready || !buf_frame) {
+		pr_err("%s: mmc_ioc_rpmb_req is not prepared\n",
+				mmc_hostname(card->host));
+		return -EINVAL;
+	}
+
+	type = p_req->type;
+	blks = p_req->blk_cnt;
+
+	/*
+ * STEP 1: send request to RPMB partition
+	 */
+	if (type == RPMB_WRITE_DATA)
+		err = mmc_rpmb_send_command(card, buf_frame, blks,
+				type, RPMB_REQ);
+	else
+		err = mmc_rpmb_send_command(card, buf_frame, 1, type, RPMB_REQ);
+
+	if (err) {
+		pr_err("%s: request write counter failed (%d)\n",
+				mmc_hostname(card->host), err);
+		goto out;
+	}
+
+	memset(buf_frame, 0, 512 * blks);
+	/*
+	 * STEP 2: check write result
+	 * Only for WRITE_DATA or Program key
+	 */
+	if (type == RPMB_WRITE_DATA) {
+		buf_frame[RPMB_TYPE_BEG + 1] = RPMB_RESULT_READ;
+		err = mmc_rpmb_send_command(card, buf_frame, 1,
+				RPMB_RESULT_READ, RPMB_REQ);
+		if (err) {
+			pr_err("%s: request write counter failed (%d)\n",
+					mmc_hostname(card->host), err);
+			goto out;
+		}
+	}
+
+	/*
+	 * STEP 3: get response from RPMB partition
+	 */
+
+	if (type == RPMB_READ_DATA)
+		err = mmc_rpmb_send_command(card, buf_frame,
+				blks, type, RPMB_RESP);
+	else
+		err = mmc_rpmb_send_command(card, buf_frame,
+				1, type, RPMB_RESP);
+	if (err) {
+		pr_err("%s: response write counter failed (%d)\n",
+				mmc_hostname(card->host), err);
+	}
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_rpmb_partition_ops);
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 2f3d2a5..7e157fb 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -732,7 +732,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "en25qh256", INFO(0x1c7019, 0, 64 * 1024, 512, 0) },
 
 	/* Everspin */
-	{ "mr25h256", CAT25_INFO(  32 * 1024, 1, 256, 2) },
+//	{ "mr25h256", CAT25_INFO(  32 * 1024, 1, 256, 2) },  // (Sylvia marked)
 
 	/* GigaDevice */
 	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
@@ -805,7 +805,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "m25p64",  INFO(0x202017,  0,  64 * 1024, 128, 0) },
 	{ "m25p128", INFO(0x202018,  0, 256 * 1024,  64, 0) },
 	{ "n25q032", INFO(0x20ba16,  0,  64 * 1024,  64, 0) },
-
+/* (Sylvia marked)
 	{ "m25p05-nonjedec",  INFO(0, 0,  32 * 1024,   2, 0) },
 	{ "m25p10-nonjedec",  INFO(0, 0,  32 * 1024,   4, 0) },
 	{ "m25p20-nonjedec",  INFO(0, 0,  64 * 1024,   4, 0) },
@@ -815,7 +815,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "m25p32-nonjedec",  INFO(0, 0,  64 * 1024,  64, 0) },
 	{ "m25p64-nonjedec",  INFO(0, 0,  64 * 1024, 128, 0) },
 	{ "m25p128-nonjedec", INFO(0, 0, 256 * 1024,  64, 0) },
-
+*/
 	{ "m45pe10", INFO(0x204011,  0, 64 * 1024,    2, 0) },
 	{ "m45pe80", INFO(0x204014,  0, 64 * 1024,   16, 0) },
 	{ "m45pe16", INFO(0x204015,  0, 64 * 1024,   32, 0) },
@@ -846,11 +846,11 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
-	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
+/*	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
 	{ "cat25c03", CAT25_INFO(  32, 8, 16, 2) },
 	{ "cat25c09", CAT25_INFO( 128, 8, 32, 2) },
 	{ "cat25c17", CAT25_INFO( 256, 8, 32, 2) },
-	{ "cat25128", CAT25_INFO(2048, 8, 64, 2) },
+	{ "cat25128", CAT25_INFO(2048, 8, 64, 2) },  (Sylvia marked) */ 
 	{ },
 };
 MODULE_DEVICE_TABLE(spi, m25p_ids);
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 107801e..316f942 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -150,6 +150,9 @@
 
 #define FLEXCAN_MB_CODE_MASK		(0xf0ffffff)
 
+/*Chris add Steven's content - workaround: if disable FLEXCAN echo, unmark next line*/
+//#define VAB820_DISABLE_FLEXCAN_ECHO
+
 /*
  * FLEXCAN hardware feature flags
  *
@@ -349,6 +352,10 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	const struct flexcan_priv *priv = netdev_priv(dev);
 	struct flexcan_regs __iomem *regs = priv->base;
 	struct can_frame *cf = (struct can_frame *)skb->data;
+	#ifdef VAB820_DISABLE_FLEXCAN_ECHO
+		//Chris add the Ken modified content
+		struct net_device_stats *stats = &dev->stats;
+	#endif
 	u32 can_id;
 	u32 ctrl = FLEXCAN_MB_CNT_CODE(0xc) | (cf->can_dlc << 16);
 
@@ -375,8 +382,10 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		u32 data = be32_to_cpup((__be32 *)&cf->data[4]);
 		flexcan_write(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[1]);
 	}
-
-	can_put_echo_skb(skb, dev, 0);
+	#ifndef VAB820_DISABLE_FLEXCAN_ECHO
+		//Chris add Ken's modified content
+		can_put_echo_skb(skb, dev, 0);
+	#endif
 
 	flexcan_write(can_id, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_id);
 	flexcan_write(ctrl, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
@@ -385,6 +394,11 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
 		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
 	}
+	#ifdef VAB820_DISABLE_FLEXCAN_ECHO
+		/*Chris add Ken's content - tx packet count*/
+		stats->tx_bytes += cf->can_dlc;
+		stats->tx_packets++;
+	#endif
 
 	return NETDEV_TX_OK;
 }
@@ -651,7 +665,11 @@ static int flexcan_poll(struct napi_struct *napi, int quota)
 static irqreturn_t flexcan_irq(int irq, void *dev_id)
 {
 	struct net_device *dev = dev_id;
-	struct net_device_stats *stats = &dev->stats;
+	#ifndef VAB820_DISABLE_FLEXCAN_ECHO
+		//Chris add Ken's modified content
+		/*Steven: use VAB820_DISABLE_FLEXCAN_ECHO to disable it*/
+		struct net_device_stats *stats = &dev->stats;
+	#endif
 	struct flexcan_priv *priv = netdev_priv(dev);
 	struct flexcan_regs __iomem *regs = priv->base;
 	u32 reg_iflag1, reg_esr;
@@ -695,8 +713,12 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 
 	/* transmission complete interrupt */
 	if (reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {
-		stats->tx_bytes += can_get_echo_skb(dev, 0);
-		stats->tx_packets++;
+		#ifndef VAB820_DISABLE_FLEXCAN_ECHO
+			/*Chris add Ken's modified content - The disable can_get_echo_skb
+		and stats->tx* counters in flexcan_start_xmit() */
+			stats->tx_bytes += can_get_echo_skb(dev, 0);
+			stats->tx_packets++;
+		#endif
 		can_led_event(dev, CAN_LED_EVENT_TX);
 		flexcan_write((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);
 		netif_wake_queue(dev);
diff --git a/drivers/of/base.c b/drivers/of/base.c
index fad95c8..352b361 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1579,6 +1579,35 @@ static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 		 ap->alias, ap->stem, ap->id, of_node_full_name(np));
 }
 
+/*
+ * of_alias_max_index() - get the maximum index for a given alias stem
+ * @stem:   The alias stem for which the maximum index is searched for
+ *
+ * Given an alias stem (the alias without the number) this function
+ * returns the maximum number for which an alias exists.
+ *
+ * Return: The maximum existing alias index or -ENODEV if no alias
+ *         exists for this stem.
+ */
+int of_alias_max_index(const char *stem)
+{
+	struct alias_prop *app;
+	int max = -ENODEV;
+
+	mutex_lock(&of_aliases_mutex);
+
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem))
+			continue;
+		if (app->id > max)
+			max = app->id;
+	}
+
+	mutex_unlock(&of_aliases_mutex);
+
+	return max;
+}
+
 /**
  * of_alias_scan - Scan all properties of 'aliases' node
  *
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index 2c7d647..2967edf 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -38,6 +38,8 @@
 #include <linux/spinlock.h>
 #include <linux/of_device.h>
 #include <linux/mod_devicetable.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
 #include "mxc_dispdrv.h"
 
 #define DISPDRV_LDB	"ldb"
@@ -78,6 +80,9 @@
 
 #define LDB_SPLIT_MODE_EN		0x00000010
 
+#define IMX_GPIO_NR(bank, nr)		(((bank) - 1) * 32 + (nr))
+#define MX6Q_SABRELITE_GPIO6_15		IMX_GPIO_NR(6, 15)
+
 enum {
 	IMX6_LDB,
 };
@@ -132,10 +137,20 @@ struct ldb_data {
 	struct notifier_block nb;
 };
 
+static __iomem *lvdsen_reg_base1 = 0;
 static int g_ldb_mode;
+static int __ldb_current_status = -1;
 
 static struct fb_videomode ldb_modedb[] = {
 	{
+	"480C60", 60, 800, 480,29850,
+	   89, 164,
+	   23, 10,
+	   10, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
+	{
 	 "LDB-WXGA", 60, 1280, 800, 14065,
 	 40, 40,
 	 10, 3,
@@ -159,6 +174,22 @@ static struct fb_videomode ldb_modedb[] = {
 	 0,
 	 FB_VMODE_NONINTERLACED,
 	 FB_MODE_IS_DETAILED,},
+	 {
+	 "LDB-SXGA", 60, 1280, 1024, KHZ2PICOS(108000),
+	 248, 48,
+	 38, 1,
+	 112, 3,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
+	 {
+	 "LDB-WSXGA+", 60, 1680, 1050, KHZ2PICOS(146250),
+	 280, 104,
+	 30, 3,
+	 176, 6,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
 };
 static int ldb_modedb_sz = ARRAY_SIZE(ldb_modedb);
 
@@ -436,6 +467,35 @@ int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 				clk_enable(ldb->setting[index].ldb_di_clk);
 				ldb->setting[index].clk_en = true;
 			}
+
+			/* Pull up the LVDS_EN (Backlight) */
+			/* We need to keep the same logic as mxcfb_blank. If current status is already UNBLANK
+			 * Some utilitys, such as x11perf, will call FB_BLANK_UNBLANK after they draw one frame,
+			 * in this case, if we still go on setting, the screen will have twinkle.*/
+			if (lvdsen_reg_base1 && (__ldb_current_status != FB_BLANK_UNBLANK)){
+				// Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio6
+				int reg_val = 0;
+				reg_val = readl(lvdsen_reg_base1);
+				reg_val &= 0xfffffff8;
+				reg_val |= 0x5; // [2:0] = 101; 
+				writel(reg_val, lvdsen_reg_base1);
+
+				// Set GPIO6[15] to high
+				{
+					gpio_request(MX6Q_SABRELITE_GPIO6_15, "gpio6_15");
+					gpio_direction_output(MX6Q_SABRELITE_GPIO6_15, 1);
+					msleep(100);
+
+				// Sometimes, the LVDS panel can not be lighted after reboot, but can be actived in user space
+				// by operating the sysfs node, so we did the same action as user space did.
+					gpio_set_value(MX6Q_SABRELITE_GPIO6_15, 0); 
+					msleep(200);
+					gpio_set_value(MX6Q_SABRELITE_GPIO6_15, 1);
+
+				// If do not release it, user space can not operate gpio by sysfs.
+					gpio_free(MX6Q_SABRELITE_GPIO6_15);
+				}
+			}
 		} else {
 			if (ldb->setting[index].clk_en) {
 				clk_disable(ldb->setting[index].ldb_di_clk);
@@ -448,6 +508,7 @@ int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 						readl(ldb->control_reg));
 			}
 		}
+		__ldb_current_status = *((int *)event->data); // Save the blank status
 		break;
 	}
 	case FB_EVENT_SUSPEND:
@@ -992,7 +1053,15 @@ static int ldb_probe(struct platform_device *pdev)
 
 	dev_set_drvdata(&pdev->dev, ldb);
 
+	// Remap for seting NANDF_CS2 to work as GPIO6[15];
+	lvdsen_reg_base1 = ioremap(0x020e02ec, 4);
+	if (lvdsen_reg_base1 == NULL) {
+		printk("%s %d: ioremap for lvds_en failed!\n", __FUNCTION__,__LINE__);
+		goto alloc_failed;
+	}
+
 	dev_dbg(&pdev->dev, "%s exit\n", __func__);
+alloc_failed:
 	return ret;
 }
 
@@ -1004,6 +1073,7 @@ static int ldb_remove(struct platform_device *pdev)
 		return 0;
 	mxc_dispdrv_puthandle(ldb->disp_ldb);
 	mxc_dispdrv_unregister(ldb->disp_ldb);
+	kfree(ldb);
 	return 0;
 }
 
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index e510025..c89db89 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -925,7 +925,6 @@ static u8 hdmi_edid_i2c_read(struct mxc_hdmi *hdmi,
 	u8 spointer = blockno / 2;
 	u8 edidaddress = ((blockno % 2) * 0x80) + addr;
 	u8 data;
-
 	hdmi_writeb(0xFF, HDMI_IH_I2CM_STAT0);
 	hdmi_writeb(edidaddress, HDMI_I2CM_ADDRESS);
 	hdmi_writeb(spointer, HDMI_I2CM_SEGADDR);
@@ -1756,7 +1755,6 @@ static void hdmi_disable_overflow_interrupts(void)
 static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
-
 	/* Don't notify if we aren't registered yet */
 	WARN_ON(!hdmi->fb_reg);
 
@@ -1769,6 +1767,7 @@ static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi)
 	 * So by the end of this function, mxc_hdmi_setup()
 	 * will be done.
 	 */
+
 	hdmi->fbi->var.activate |= FB_ACTIVATE_FORCE;
 	console_lock();
 	hdmi->fbi->flags |= FBINFO_MISC_USEREVENT;
@@ -1816,6 +1815,7 @@ static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
 	}
 
 	console_unlock();
+
 }
 
 static void  mxc_hdmi_default_edid_cfg(struct mxc_hdmi *hdmi)
@@ -1847,6 +1847,7 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 	}
 
 	console_unlock();
+
 }
 
 static void mxc_hdmi_set_mode_to_vga_dvi(struct mxc_hdmi *hdmi)
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index a6dc049..45229ff 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -83,6 +83,7 @@ struct mmc_ext_csd {
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
 	bool			bkops;		/* background support bit */
 	bool			bkops_en;	/* background enable bit */
+	unsigned int		rpmb_size;		/* Units: half sector */
 	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
@@ -298,6 +299,7 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
+	unsigned int		rpmb_max_req;
 };
 
 /*
@@ -523,5 +525,6 @@ extern void mmc_unregister_driver(struct mmc_driver *);
 
 extern void mmc_fixup_device(struct mmc_card *card,
 			     const struct mmc_fixup *table);
-
+extern int mmc_rpmb_req_handle(struct device *emmc,
+		struct mmc_ioc_rpmb_req *req);
 #endif /* LINUX_MMC_CARD_H */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 39613b9..6caa8db 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -10,6 +10,8 @@
 
 #include <linux/interrupt.h>
 #include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/mmc/ioctl.h>
 
 struct request;
 struct mmc_data;
@@ -135,6 +137,34 @@ struct mmc_request {
 	struct mmc_host		*host;
 };
 
+/*
+ * RPMB frame structure for MMC core stack
+ */
+struct mmc_core_rpmb_req {
+	struct mmc_ioc_rpmb_req *req;
+	__u8 *frame;
+	bool ready;
+};
+
+#define RPMB_PROGRAM_KEY       1       /* Program RPMB Authentication Key */
+#define RPMB_GET_WRITE_COUNTER 2       /* Read RPMB write counter */
+#define RPMB_WRITE_DATA		3	/* Write data to RPMB partition */
+#define RPMB_READ_DATA         4       /* Read data from RPMB partition */
+#define RPMB_RESULT_READ       5       /* Read result request */
+#define RPMB_REQ               1       /* RPMB request mark */
+#define RPMB_RESP              (1 << 1)/* RPMB response mark */
+#define RPMB_AVALIABLE_SECTORS 8       /* 4K page size */
+
+#define RPMB_TYPE_BEG          510
+#define RPMB_RES_BEG           508
+#define RPMB_BLKS_BEG          506
+#define RPMB_ADDR_BEG          504
+#define RPMB_WCOUNTER_BEG      500
+
+#define RPMB_NONCE_BEG         484
+#define RPMB_DATA_BEG          228
+#define RPMB_MAC_BEG           196
+
 struct mmc_card;
 struct mmc_async_req;
 
@@ -153,6 +183,11 @@ extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool);
 extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
 
+extern int mmc_rpmb_partition_ops(struct mmc_core_rpmb_req *,
+		struct mmc_card *);
+extern int mmc_rpmb_pre_frame(struct mmc_core_rpmb_req *, struct mmc_card *);
+extern void mmc_rpmb_post_frame(struct mmc_core_rpmb_req *);
+
 #define MMC_ERASE_ARG		0x00000000
 #define MMC_SECURE_ERASE_ARG	0x80000000
 #define MMC_TRIM_ARG		0x00000001
@@ -192,6 +227,9 @@ extern int mmc_flush_cache(struct mmc_card *);
 
 extern int mmc_detect_card_removed(struct mmc_host *host);
 
+int mmc_first_nonreserved_index(void);
+int mmc_get_reserved_index(struct mmc_host *host);
+
 /**
  *	mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
diff --git a/include/linux/of.h b/include/linux/of.h
index 429e168..71023c6 100644
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@ -285,6 +285,7 @@ extern int of_count_phandle_with_args(const struct device_node *np,
 
 extern void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align));
 extern int of_alias_get_id(struct device_node *np, const char *stem);
+extern int of_alias_max_index(const char *stem);
 
 extern int of_machine_is_compatible(const char *compat);
 
@@ -502,6 +503,11 @@ static inline int of_alias_get_id(struct device_node *np, const char *stem)
 	return -ENOSYS;
 }
 
+static inline int of_alias_max_index(const char *stem)
+{
+	return -ENODEV;
+}
+
 static inline int of_machine_is_compatible(const char *compat)
 {
 	return 0;
diff --git a/include/uapi/linux/mmc/ioctl.h b/include/uapi/linux/mmc/ioctl.h
index 1f5e689..511f26e 100644
--- a/include/uapi/linux/mmc/ioctl.h
+++ b/include/uapi/linux/mmc/ioctl.h
@@ -46,6 +46,18 @@ struct mmc_ioc_cmd {
 #define mmc_ioc_cmd_set_data(ic, ptr) ic.data_ptr = (__u64)(unsigned long) ptr
 
 #define MMC_IOC_CMD _IOWR(MMC_BLOCK_MAJOR, 0, struct mmc_ioc_cmd)
+struct mmc_ioc_rpmb_req {
+	__u16 type;                     /* RPMB request type */
+	__u16 *result;                  /* response or request result */
+	__u16 blk_cnt;                  /* Number of blocks(half sector 256B) */
+	__u16 addr;                     /* data address */
+	__u32 *wc;                      /* write counter */
+	__u8 *nonce;                    /* Ramdom number */
+	__u8 *data;                     /* Buffer of the user data */
+	__u8 *mac;                      /* Message Authentication Code */
+};
+
+#define MMC_IOC_RPMB_REQ _IOWR(MMC_BLOCK_MAJOR, 1, struct mmc_ioc_rpmb_req)
 
 /*
  * Since this ioctl is only meant to enhance (and not replace) normal access
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index ea47938..c3485c9 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -60,6 +60,33 @@ static const u16 sgtl5000_regs[SGTL5000_MAX_REG_OFFSET] =  {
 	[SGTL5000_DAP_AVC_DECAY] = 0x0050,
 };
 
+u16 init_regs[] = {
+	SGTL5000_CHIP_CLK_CTRL, 0x0008,
+	SGTL5000_CHIP_I2S_CTRL, 0x0010,
+	SGTL5000_CHIP_SSS_CTRL, 0x0010,
+	SGTL5000_CHIP_DAC_VOL, 0x3c3c,
+	SGTL5000_CHIP_PAD_STRENGTH, 0x015f,
+	SGTL5000_CHIP_ANA_HP_CTRL, 0x1818,
+	SGTL5000_CHIP_ANA_CTRL, 0x0111,
+	SGTL5000_CHIP_LINE_OUT_VOL, 0x0404,
+	SGTL5000_CHIP_ANA_POWER, 0x7060,
+	SGTL5000_CHIP_PLL_CTRL, 0x5000,
+	SGTL5000_DAP_BASS_ENHANCE, 0x0040,
+	SGTL5000_DAP_BASS_ENHANCE_CTRL, 0x051f,
+	SGTL5000_DAP_SURROUND, 0x0040,
+	SGTL5000_DAP_EQ_BASS_BAND0, 0x002f,
+	SGTL5000_DAP_EQ_BASS_BAND1, 0x002f,
+	SGTL5000_DAP_EQ_BASS_BAND2, 0x002f,
+	SGTL5000_DAP_EQ_BASS_BAND3, 0x002f,
+	SGTL5000_DAP_EQ_BASS_BAND4, 0x002f,
+	SGTL5000_DAP_MAIN_CHAN, 0x8000,
+	SGTL5000_DAP_AVC_CTRL, 0x0510,
+	SGTL5000_DAP_AVC_THRESHOLD, 0x1473,
+	SGTL5000_DAP_AVC_ATTACK, 0x0028,
+	SGTL5000_DAP_AVC_DECAY, 0x0050,
+};
+
+
 /* regulator supplies for sgtl5000, VDDD is an optional external supply */
 enum sgtl5000_regulator_supplies {
 	VDDA,
@@ -112,6 +139,8 @@ struct sgtl5000_priv {
 	int fmt;	/* i2s data format */
 	struct regulator_bulk_data supplies[SGTL5000_SUPPLY_NUM];
 	struct ldo_regulator *ldo;
+	struct clk *mclk;
+	int revision;
 };
 
 /*
@@ -1214,9 +1243,7 @@ static int sgtl5000_replace_vddd_with_ldo(struct snd_soc_codec *codec)
 
 static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 {
-	u16 reg;
 	int ret;
-	int rev;
 	int i;
 	int external_vddd = 0;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
@@ -1242,24 +1269,11 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	/* wait for all power rails bring up */
 	udelay(10);
 
-	/* read chip information */
-	reg = snd_soc_read(codec, SGTL5000_CHIP_ID);
-	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
-	    SGTL5000_PARTID_PART_ID) {
-		dev_err(codec->dev,
-			"Device with ID register %x is not a sgtl5000\n", reg);
-		ret = -ENODEV;
-		goto err_regulator_disable;
-	}
-
-	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
-	dev_info(codec->dev, "sgtl5000 revision 0x%x\n", rev);
-
 	/*
 	 * workaround for revision 0x11 and later,
 	 * roll back to use internal LDO
 	 */
-	if (external_vddd && rev >= 0x11) {
+	if (external_vddd && sgtl5000->revision >= 0x11) {
 		/* disable all regulator first */
 		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
@@ -1282,9 +1296,6 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 
 	return 0;
 
-err_regulator_disable:
-	regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
-				sgtl5000->supplies);
 err_regulator_free:
 	regulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),
 				sgtl5000->supplies);
@@ -1317,8 +1328,7 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 
 	/* enable small pop, introduce 400ms delay in turning off */
 	snd_soc_update_bits(codec, SGTL5000_CHIP_REF_CTRL,
-				SGTL5000_SMALL_POP,
-				SGTL5000_SMALL_POP);
+				SGTL5000_SMALL_POP, 1);
 
 	/* disable short cut detector */
 	snd_soc_write(codec, SGTL5000_CHIP_SHORT_CTRL, 0);
@@ -1404,28 +1414,128 @@ static struct snd_soc_codec_driver sgtl5000_driver = {
 	.num_dapm_routes = ARRAY_SIZE(sgtl5000_dapm_routes),
 };
 
+static s32 sgtl5000_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int retry = 0;
+	int ret;
+	u8 buf[4];
+	struct i2c_msg msgs[2];
+
+	while (retry++ < 3) {
+		buf[0] = reg >> 8;
+		buf[1] = reg & 0xff;
+		msgs[0].addr = client->addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 2;
+		msgs[0].buf = buf;
+		msgs[1].addr = client->addr;
+		msgs[1].flags = I2C_M_RD;
+		msgs[1].len = 2;
+		msgs[1].buf = buf;
+
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret == 2) {
+			*val = (buf[0] << 8) | buf[1];
+			return 0;
+		}
+		pr_err("%s: ret=%d reg=%x addr=%x\n", __func__, ret, reg, client->addr);
+	}
+	return (ret < 0) ? ret : -EIO;
+}
+
+static s32 sgtl5000_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int retry = 0;
+	int ret;
+	u8 buf[4];
+	struct i2c_msg msgs[1];
+
+	while (retry++ < 3) {
+		buf[0] = reg >> 8;
+		buf[1] = reg & 0xff;
+		buf[2] = val >> 8;
+		buf[3] = val & 0xff;
+		msgs[0].addr = client->addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 4;
+		msgs[0].buf = buf;
+
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret == 1)
+			return 0;
+		pr_err("%s: ret=%d reg=%x addr=%x\n", __func__, ret, reg, client->addr);
+	}
+	return (ret < 0) ? ret : -EIO;
+}
+
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
 	struct sgtl5000_priv *sgtl5000;
-	int ret;
+	int ret, rev, i;
+	u16 reg;
 
 	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
 								GFP_KERNEL);
 	if (!sgtl5000)
 		return -ENOMEM;
 
+	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
+	if (IS_ERR(sgtl5000->mclk)) {
+		ret = PTR_ERR(sgtl5000->mclk);
+		dev_err(&client->dev, "Failed to get mclock: %d\n", ret);
+		/* Defer the probe to see if the clk will be provided later */
+		if (ret == -ENOENT)
+			return -EPROBE_DEFER;
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sgtl5000->mclk);
+	if (ret)
+		return ret;
+
+	/* read chip information */
+	ret = sgtl5000_read16(client, SGTL5000_CHIP_ID, &reg);
+	if (ret < 0) {
+		ret = -ENODEV;
+		goto disable_clk;
+	}
+
+	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
+	    SGTL5000_PARTID_PART_ID) {
+		dev_err(&client->dev,
+			"Device with ID register %x is not a sgtl5000\n", reg);
+		ret = -ENODEV;
+		goto disable_clk;
+	}
+
+	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
+	dev_info(&client->dev, "sgtl5000 revision 0x%x\n", rev);
+	sgtl5000->revision = rev;
+
+	/* Restore regs back to power up conditions */
+	for (i = 0; i < ARRAY_SIZE(init_regs); i += 2)
+		sgtl5000_write16(client, init_regs[i], init_regs[i+1]);
+
 	i2c_set_clientdata(client, sgtl5000);
 
 	ret = snd_soc_register_codec(&client->dev,
 			&sgtl5000_driver, &sgtl5000_dai, 1);
+	if (ret)
+		goto disable_clk;
+	return ret;
+
+disable_clk:
+	clk_disable_unprepare(sgtl5000->mclk);
 	return ret;
 }
 
 static int sgtl5000_i2c_remove(struct i2c_client *client)
 {
-	snd_soc_unregister_codec(&client->dev);
+	struct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);
 
+	snd_soc_unregister_codec(&client->dev);
+	clk_disable_unprepare(sgtl5000->mclk);
 	return 0;
 }
 
@@ -1458,3 +1568,4 @@ module_i2c_driver(sgtl5000_i2c_driver);
 MODULE_DESCRIPTION("Freescale SGTL5000 ALSA SoC Codec Driver");
 MODULE_AUTHOR("Zeng Zhaoming <zengzm.kernel@gmail.com>");
 MODULE_LICENSE("GPL");
+
